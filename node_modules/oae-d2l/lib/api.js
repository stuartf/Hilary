/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var http = require('http');
var https = require('https');
var request = require('request');
var temp = require('temp');
var url = require('url');

var ContentAPI = require('oae-content');
var D2LConfig = require('oae-config').config('oae-d2l');
var D2LDAO = require('./internal/dao');
var log = require('oae-logger').logger('oae-d2l');
var Server = require('oae-util/lib/server');
var Validator = require('oae-util/lib/validator').Validator;

var D2L = require('valence');

// Some constants, Version might need to move to config for interacting with various d2l installs
var D2L_API_VERSION = '1.1';

var validator = new Validator();

var _getD2LAPIPrefix = function(section) {
    return '/d2l/api/' + section + '/' + D2L_API_VERSION;
};

/**
 * Determine if the currently logged in user is authenticated to D2L
 */
var isAuthed = module.exports.isAuthed = function(ctx, redirect, callback) {
    validator.check(ctx.user().id, {'code': 400, 'msg': 'Anonymous users can not be authed to d2l'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _getUserSession(ctx, function(err, session) {
        if (!err && session) {
            return callback(null, true, null);
        }
        // No cached credentials
        return callback(null, false, _getAuthUrl(ctx, redirect));
    });
};

/**
 * Save the current user's D2L credentials so we don't have to keep asking them
 */
var cacheUserCreds = module.exports.cacheUserCreds = function(ctx, d2lCallbackUrl, callback) {
    var config = _getConfig(ctx.tenant().alias);
    var userContext = config.appContext.createUserContext(config.host, config.port, d2lCallbackUrl);
    if (userContext && userContext.userId) {
        return D2LDAO.saveD2LUser(ctx.user().id, userContext.userId, userContext.userKey, callback);
    }
    return callback({'code': 500, 'msg': 'Could not get D2L userContext'});
};

/**
 * Get the current user's enrollments
 */
var getEnrollments = module.exports.getEnrollments = function(ctx, callback) {
    var d2lUrl = _getD2LAPIPrefix('lp') + '/enrollments/myenrollments/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        // Only get Course enrollments
        signedUrl += '&orgUnitTypeId=3';
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
            body = JSON.parse(body);
            _unpackPagedEnrollments(ctx, body.PagingInfo, body.Items, function(err, courses) {
                if (err) {
                    return callback(err);
                }
                // Filter courses to only those which are active and we can access
                courses = _.filter(courses, function(course) {
                    return (course.Access.IsActive && course.Access.CanAccess);
                });
                // Pull out the fields we care about
                courses = _.map(courses, function(course) {
                    return _.pick(course.OrgUnit, 'Id', 'Name', 'Code');
                });

                var done = _.after(courses.length, function() {
                    callback(null, _.filter(courses, function(course) {
                        return (! _.isEmpty(course.assignments));
                    }));
                });

                // Attach the list of open assignments
                _.each(courses, function(course) {
                    _getDropboxes(ctx, course.Id, function(err, dropboxes) {
                        if (err) {
                            return callback(err);
                        }
                        dropboxes = _.map(dropboxes, function(dropbox) {
                            return _.pick(dropbox, 'Id', 'Name', 'CustomInstructions', 'Availability');
                        });
                        course.assignments = dropboxes;
                        done();
                    });
                });
            });
        });
    });
};

/**
 *
 */
var submitToD2L = module.exports.submitToD2L = function(ctx, contentId, courseId, assignmentId, description, callback) {
    validator.check(ctx.user().id, {'code': 400, 'msg': 'Anonymous users can not be authed to d2l'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var protocol = Server.useHttps() ? 'https://' : 'http://';
    var contentProfileUrl = protocol + ctx.tenant().host + '/content/' + ctx.tenant().alias + '/' + contentId;
    description = description || {
        'Text': 'Content submitted from OAE, see the original at ' + contentProfileUrl,
        'Html': 'Content submitted from OAE, <a href="' + contentProfileUrl + '">see the original</a>'
    };
    ContentAPI.getContent(ctx, contentId, function(err, contentProfile) {
        if (err) {
            return callback(err);
        }
        var contentPath = contentProfile.downloadPath;
        // Check for full qualification
        if (contentPath[0] === '/') {
            contentPath = protocol + ctx.tenant().host + contentPath;
        }
        var stream = temp.createWriteStream();
        request.get(contentPath, function(err, response, body){

            var d2lUrl = _getD2LAPIPrefix('le') + '/' + courseId + '/dropbox/folders/' + assignmentId + '/submissions/mysubmissions/';
            _getSignedUrl(ctx, d2lUrl, 'POST', function(err, signedUrl) {
                if (err) {
                    return callback(err);
                }

                // Upload as multipart/mixed
                var options = url.parse(signedUrl, true);
                var boundary = 'fd88feef9d6e03551e4d7aa4b6a48f00';
                options.method = 'POST';
                options.headers = {'Content-Type': 'multipart/mixed; boundary=' + boundary};

                var myhttp = _getConfig(ctx.tenant().alias).protocol === 'https://' ? https : http;

                var req = myhttp.request(options, function(res) {
                    res.on('data', function(chunk) {
                        log().info(chunk);
                    });
                });

                req.on('error', function(err) {
                    log().error(err);
                    return callback(err);
                });

                req.write('--' + boundary);
                req.write('Content-Type: application/json');
                req.write(JSON.stringify(description) + '\n');
                req.write('--' + boundary);
                req.write('Content-Type: ' + contentProfile.mime);
                /*var readStream = fs.createReadStream(stream.path).pipe(req, {'end': false});
                readStream.on('end', function() {
                    req.write('--' + boundary + '--\n');
                    req.end();
                    fs.unlink(stream.path, function(){});
                    return callback(null, {});
                });*/
                var fileContent = fs.readFileSync(stream.path);
                req.write(fileContent);
                req.write('--' + boundary + '--\n');
                req.end();
                // TODO Save info about this submission to cassandra
                // Clean up temp file
                fs.unlink(stream.path, function(){});
                return callback(null, {});
            });
        }).pipe(stream);
    });
};

/**
 * Keep getting courses until we have all of them
 */
var _unpackPagedEnrollments = function(ctx, pagingInfo, items, callback) {
    if (! pagingInfo.HasMoreItems) {
        return callback(null, items);
    }
    var d2lUrl = _getD2LAPIPrefix('lp') + '/enrollments/myenrollments/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        // Only get Course enrollments and start from the bookmark
        signedUrl += '&orgUnitTypeId=3&bookmark=' + pagingInfo.Bookmark;
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
        });
        _unpackPagedEnrollments(ctx, body.pagingInfo, _.union(items, body.Items), callback);
    });
};

var _getDropboxes = function(ctx, courseId, callback) {
    var d2lUrl = _getD2LAPIPrefix('le') + '/' + courseId + '/dropbox/folders/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
            body = JSON.parse(body);
            callback(null, body);
        });
    });
};

/**
 * Get the d2l auth url for this tenant
 */
var _getAuthUrl = function(ctx, redirect) {
    redirect = redirect || '/me';
    var config = _getConfig(ctx.tenant().alias);
    var callbackProtocol = Server.useHttps() ? 'https://' : 'http://';
    var callbackUrl = callbackProtocol + ctx.tenant().host + '/api/d2l/callback?oaeContext=' + redirect;
    return config.appContext.createUrlForAuthentication(config.protocol + config.host, config.port, callbackUrl);
};

/**
 * Get a d2l user context for the current OAE user
 */
var _getUserSession = function(ctx, callback) {
    D2LDAO.getD2LUser(ctx.user().id, function(err, d2lUser) {
        if (err) {
            return callback(err);
        }
        var config = _getConfig(ctx.tenant().alias);
        var session = config.appContext.createUserContextWithValues(config.host, config.port, d2lUser.d2lUserId, d2lUser.d2lUserKey);
        if (_.isEmpty(d2lUser)) {
            return callback({'code': 500, 'msg': 'No cached D2L user for that ID'});
        }
        log().trace(session);
        return callback(null, session);
    });
};

/**
 * Get the D2L config values for a tenant
 */
var _getConfig = function(tenantAlias) {
    var config = {};
    var _getConfigVal = function(key) {
        return D2LConfig.getValue(tenantAlias, 'd2l', key);
    };
    config.protocol = _getConfigVal('protocol');
    config.host = _getConfigVal('host');
    config.port = _getConfigVal('port');
    var d2lUrl = config.protocol + config.host + ':' + config.port;
    var appId = _getConfigVal('appId');
    var appKey = _getConfigVal('appKey');
    config.appContext = new D2L.ApplicationContext(d2lUrl, appId, appKey);
    return config;
};

/**
 * Get a signed authenticated url
 */
var _getSignedUrl = function(ctx, req, method, callback) {
    var config = _getConfig(ctx.tenant().alias);
    _getUserSession(ctx, function(err, session){
        if (err) {
            return callback(err);
        }
        if (! session) {
            return callback({'code': 500, 'msg': 'Could not get D2L userContext'});
        }
        return callback(null, config.protocol + session.createAuthenticatedUrl(req, method));
    });
};
