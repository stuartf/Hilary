/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var fs = require('fs');
var http = require('http');
var https = require('https');
var request = require('request');
var temp = require('temp');
var url = require('url');

var ContentAPI = require('oae-content');
var D2LConfig = require('oae-config').config('oae-d2l');
var D2LDAO = require('./internal/dao');
var log = require('oae-logger').logger('oae-d2l');
var Server = require('oae-util/lib/server');
var Validator = require('oae-util/lib/validator').Validator;

var D2L = require('valence');

// Some constants, Version might need to move to config for interacting with various d2l installs
var D2L_API_VERSION = '1.1';

var validator = new Validator();

var _getD2LAPIPrefix = function(section) {
    return '/d2l/api/' + section + '/' + D2L_API_VERSION;
};

/**
 * Determine if the currently logged in user is authenticated to D2L
 *
 * @param  {Context}            ctx              The request context
 * @param  {String}             redirect         A URL to redirect the user after they are authenticated
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.err     An error if there is one
 * @param  {Boolean}            callback.authed  Whether the user is authenticated to D2L
 * @param  {String}             callback.url     The url the user should be redirected to for authentication
 */
var isAuthed = module.exports.isAuthed = function(ctx, redirect, callback) {
    validator.check(ctx.user().id, {'code': 400, 'msg': 'Anonymous users can not be authed to d2l'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }
    _getUserSession(ctx, function(err, session) {
        if (!err && session) {
            return callback(null, true, null);
        }
        // No cached credentials
        return callback(null, false, _getAuthUrl(ctx, redirect));
    });
};

/**
 * Save the current user's D2L credentials so we don't have to keep asking them
 *
 * @param  {Context}            ctx              The request context
 * @param  {String}             d2lCallbackUrl   The URL that d2l should redirect the user to after authentication
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.err     An error if there is one
 */
var cacheUserCreds = module.exports.cacheUserCreds = function(ctx, d2lCallbackUrl, callback) {
    var config = _getConfig(ctx.tenant().alias);
    var userContext = config.appContext.createUserContext(config.host, config.port, d2lCallbackUrl);
    if (userContext && userContext.userId) {
        return D2LDAO.saveD2LUser(ctx.user().id, userContext.userId, userContext.userKey, callback);
    }
    return callback({'code': 500, 'msg': 'Could not get D2L userContext'});
};

/**
 * Get the current user's enrollments
 *
 * @param  {Context}            ctx              The request context
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.err     An error if there is one
 * @param  {Object}             callback.courses An object containing the user's courses that have open assignments, and those assignments
 */
var getEnrollments = module.exports.getEnrollments = function(ctx, callback) {
    var d2lUrl = _getD2LAPIPrefix('lp') + '/enrollments/myenrollments/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        // Only get Course enrollments
        signedUrl += '&orgUnitTypeId=3';
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
            body = JSON.parse(body);
            _unpackPagedEnrollments(ctx, body.PagingInfo, body.Items, function(err, courses) {
                if (err) {
                    return callback(err);
                }
                // Filter courses to only those which are active and we can access
                courses = _.filter(courses, function(course) {
                    return (course.Access.IsActive && course.Access.CanAccess);
                });
                // Pull out the fields we care about
                courses = _.map(courses, function(course) {
                    return _.pick(course.OrgUnit, 'Id', 'Name', 'Code');
                });

                var done = _.after(courses.length, function() {
                    callback(null, _.filter(courses, function(course) {
                        return (! _.isEmpty(course.assignments));
                    }));
                });

                // Attach the list of open assignments
                _.each(courses, function(course) {
                    _getDropboxes(ctx, course.Id, function(err, dropboxes) {
                        if (err) {
                            return callback(err);
                        }
                        dropboxes = _.map(dropboxes, function(dropbox) {
                            return _.pick(dropbox, 'Id', 'Name', 'CustomInstructions', 'Availability');
                        });
                        course.assignments = dropboxes;
                        done();
                    });
                });
            });
        });
    });
};

/**
 * Submit a piece of content from OAE to a D2L dropbox
 *
 * @param  {Context}            ctx              The request context
 * @param  {String}             contentId        The OAE contentId of the content to be submitted
 * @param  {Number}             courseId         The orgUnitId of the d2l course
 * @param  {Number}             assignmentId     The folderId of the d2l assignment dropbox
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.err     An error if there is one
 */
var submitToD2L = module.exports.submitToD2L = function(ctx, contentId, courseId, assignmentId, description, callback) {
    validator.check(ctx.user().id, {'code': 400, 'msg': 'Anonymous users can not be authed to d2l'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    ContentAPI.getContent(ctx, contentId, function(err, contentProfile) {
        if (err) {
            return callback(err);
        }

        var protocol = Server.useHttps() ? 'https://' : 'http://';
        var contentProfileUrl = protocol + ctx.tenant().host + contentProfile.profilePath;
        description = description || {
            'Text': 'Content submitted from OAE, see the original at ' + contentProfileUrl,
            'Html': 'Content submitted from OAE, <a href="' + contentProfileUrl + '">see the original</a>'
        };

        var contentPath = contentProfile.downloadPath;
        // Check for full qualification
        if (contentPath[0] === '/') {
            contentPath = protocol + ctx.tenant().host + contentPath;
        }
        var stream = temp.createWriteStream();
        request.get(contentPath, function(err, response, body){

            var d2lUrl = _getD2LAPIPrefix('le') + '/' + courseId + '/dropbox/folders/' + assignmentId + '/submissions/mysubmissions/';
            _getSignedUrl(ctx, d2lUrl, 'POST', function(err, signedUrl) {
                if (err) {
                    return callback(err);
                }

                // Upload as multipart/mixed
                var options = url.parse(signedUrl, true);
                var boundary = 'fd88feef9d6e03551e4d7aa4b6a48f00';
                options.method = 'POST';

                var msg = Buffer.concat([new Buffer('--' + boundary +
                    '\r\nContent-Type: application/json\r\n\r\n' +
                    JSON.stringify(description) +
                    '\r\n--' + boundary +
                    '\r\nContent-Disposition: form-data; name=""; filename="' + contentProfile.filename +
                    '"\r\nContent-Type: ' + contentProfile.mime + '\r\n\r\n'),
                    fs.readFileSync(stream.path),
                    new Buffer('\r\n--' + boundary + '--\r\n')]);

                options.headers = {
                    'Content-Type': 'multipart/mixed; boundary=' + boundary,
                    'Content-Length': msg.length
                };

                var myhttp = _getConfig(ctx.tenant().alias).protocol === 'https://' ? https : http;

                var req = myhttp.request(options, function(res) {
                    log().info({'code': res.statusCode});
                    res.on('data', function(chunk) {
                        log().info(chunk);
                    });
                });

                req.on('error', function(err) {
                    log().error(err);
                    return callback(err);
                });

                req.write(msg);
                req.end();

                D2LDAO.getD2LSubmissions(contentId, ctx.user().id, function(err, d2lSubmissions) {
                    if (err) {
                        return callback(err);
                    }

                    // TODO this should probably be locked so two nodes can't update at the same time
                    d2lSubmissions[new Date().getTime()] = {
                        'courseId': courseId,
                        'assignmentId': assignmentId,
                        'revision': contentProfile.latestRevisionId
                    };

                    D2LDAO.saveD2LSubmissions(contentId, ctx.user().id, d2lSubmissions, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        // Clean up temp file
                        fs.unlink(stream.path, function(){});
                        return callback(null, {});
                    });
                });
            });
        }).pipe(stream);
    });
};

var getD2LFeedback = module.exports.getD2LFeedback = function(ctx, contentId, callback) {
    D2LDAO.getD2LSubmissions(contentId, ctx.user().id, function(err, d2lSubmissions) {
        if (err) {
            return callback(err);
        }

        var allFeedback = [];
        var whoamiUrl = _getD2LAPIPrefix('lp') + '/users/whoami';
        _getSignedUrl(ctx, whoamiUrl, 'GET', function(err, signedUrl) {
            if (err) {
                return callback(err);
            }
            request(signedUrl, function(err, response, body) {
                if (err) {
                    return callback(err);
                }
                var whoami = JSON.parse(body);
                var entityId = whoami.Identifier;

                d2lSubmissions = _.omit(d2lSubmissions, 'contentId_userId');

                if (_.keys(d2lSubmissions).length === 0) {
                    callback(null, allFeedback);
                }

                var done = _.after(_.keys(d2lSubmissions).length, function() {
                    callback(null, allFeedback);
                });

                _.each(d2lSubmissions, function(submission, timestamp) {
                    var feedback = {};
                    submission = JSON.parse(submission);
                    feedback.timestamp = timestamp;
                    feedback.courseId = submission.courseId;
                    feedback.assignmentId = submission.assignmentId;
                    feedback.revision = submission.revision;
                    var d2lUrl = _getD2LAPIPrefix('le') + '/' + submission.courseId + '/dropbox/folders/' + submission.assignmentId + '/feedback/user/' + entityId;
                    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
                        if (err) {
                            return callback(err);
                        }
                        request(signedUrl, function(err, response, body) {
                            if (err) {
                                return callback(err);
                            }
                            feedback.d2lFeedback = JSON.parse(body);
                            allFeedback.push(feedback);
                            done();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Keep getting courses until we have all of them
 *
 * @param  {Context}            ctx              The request context
 * @param  {Object}             pagingInfo       The pagingInfo from the previous d2l enrollments page
 * @param  {Object[]}           items            The enrollments found so far
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.error   An error if there is one
 * @param  {Object[]}           callback.items   The complete list of enrollments
 * @api private
 */
var _unpackPagedEnrollments = function(ctx, pagingInfo, items, callback) {
    if (! pagingInfo.HasMoreItems) {
        return callback(null, items);
    }
    var d2lUrl = _getD2LAPIPrefix('lp') + '/enrollments/myenrollments/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        // Only get Course enrollments and start from the bookmark
        signedUrl += '&orgUnitTypeId=3&bookmark=' + pagingInfo.Bookmark;
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
        });
        _unpackPagedEnrollments(ctx, body.pagingInfo, _.union(items, body.Items), callback);
    });
};

/**
 * Get a list of all the open d2l dropboxes associated with a course
 *
 * @param  {Context}            ctx              The request context
 * @param  {Number}             courseId         The orgUnitId of a d2l course
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.error   An error if there is one
 * @param  {Object}             callback.folders The dropbox folders for the course's open assignments
 * @api private
 */
var _getDropboxes = function(ctx, courseId, callback) {
    var d2lUrl = _getD2LAPIPrefix('le') + '/' + courseId + '/dropbox/folders/';
    _getSignedUrl(ctx, d2lUrl, 'GET', function(err, signedUrl) {
        if (err) {
            return callback(err);
        }
        log().trace(signedUrl);
        request(signedUrl, function(err, response, body) {
            if (err) {
                return callback(err);
            }
            body = JSON.parse(body);
            callback(null, body);
        });
    });
};

/**
 * Get the d2l auth url for this tenant
 *
 * @param  {Context}            ctx              The request context
 * @param  {String}             redirect         A URL to redirect the user after they are authenticated
 * @return {String}                              The URL the user should be redirected to in order to auth with d2l
 * @api private
 */
var _getAuthUrl = function(ctx, redirect) {
    redirect = redirect || '/me';
    var config = _getConfig(ctx.tenant().alias);
    var callbackProtocol = Server.useHttps() ? 'https://' : 'http://';
    var callbackUrl = callbackProtocol + ctx.tenant().host + '/api/d2l/callback?oaeContext=' + redirect;
    return config.appContext.createUrlForAuthentication(config.protocol + config.host, config.port, callbackUrl);
};

/**
 * Get a d2l user context for the current OAE user
 *
 * @param  {Context}            ctx              The request context
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.error   An error if there is one
 * @param  {UserContext}        callback.session A d2l UserContext for the current user
 * @api private
 */
var _getUserSession = function(ctx, callback) {
    D2LDAO.getD2LUser(ctx.user().id, function(err, d2lUser) {
        if (err) {
            return callback(err);
        }
        var config = _getConfig(ctx.tenant().alias);
        var session = config.appContext.createUserContextWithValues(config.host, config.port, d2lUser.d2lUserId, d2lUser.d2lUserKey);
        if (_.isEmpty(d2lUser)) {
            return callback({'code': 500, 'msg': 'No cached D2L user for that ID'});
        }
        log().trace(session);
        return callback(null, session);
    });
};

/**
 * Get the D2L config values for a tenant
 *
 * @param  {String}             tenantAlias      The alias of the current tenant
 * @return {Object}                              An object containing the protocol, host, port, and a d2l ApplicationContext for this tenant's integration
 * @api private
 */
var _getConfig = function(tenantAlias) {
    var config = {};
    var _getConfigVal = function(key) {
        return D2LConfig.getValue(tenantAlias, 'd2l', key);
    };
    config.protocol = _getConfigVal('protocol');
    config.host = _getConfigVal('host');
    config.port = _getConfigVal('port');
    var d2lUrl = config.protocol + config.host + ':' + config.port;
    var appId = _getConfigVal('appId');
    var appKey = _getConfigVal('appKey');
    config.appContext = new D2L.ApplicationContext(d2lUrl, appId, appKey);
    return config;
};

/**
 * Get a signed authenticated url
 *
 * @param  {Context}            ctx              The request context
 * @param  {String}             req              The URL that needs to be signed
 * @param  {String}             method           The HTTP method that will be used when the URL is called
 * @param  {Function}           callback         Standard callback function
 * @param  {Error}              callback.error   An error if there is one
 * @param  {String}             callback.url     The signed URL
 * @api private
 */
var _getSignedUrl = function(ctx, req, method, callback) {
    var config = _getConfig(ctx.tenant().alias);
    _getUserSession(ctx, function(err, session){
        if (err) {
            return callback(err);
        }
        if (! session) {
            return callback({'code': 500, 'msg': 'Could not get D2L userContext'});
        }
        return callback(null, config.protocol + session.createAuthenticatedUrl(req, method));
    });
};
